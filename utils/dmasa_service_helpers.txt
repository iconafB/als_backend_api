from fastapi import HTTPException,status,Depends
from sqlmodel import select
from sqlalchemy.ext.asyncio.session import AsyncSession
import json
from settings.Settings import get_settings
import httpx
from typing import Annotated,List
from models.dma_service import dma_audit_id_tbl
from utils.logger import define_logger
import urllib3
import asyncio
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


dma_logger=define_logger("dmasa_logs","logs/dma.log")

class DMAClassHelper:
    
    def __init__(self):
        self.dmasa_api_key=get_settings().DMASA_API_KEY
        self.dmasa_member_id=get_settings().DMASA_MEMBER_ID
        self.check_credits_dmasa_url=get_settings().CHECK_CREDITS_DMASA_URL
        self.notification_email=get_settings().NOTIFICATION_EMAIL
        self.submit_dedupes_dmasa_url=get_settings().UPLOAD_DMASA_URL
        self.read_dmasa_dedupe_status=get_settings().READ_DMASA_DEDUPE_STATUS

        self.read_dedupe_output_url=get_settings().READ_DMASA_OUTPUT_URL
        # sane defaults
        self.client=httpx.AsyncClient(verify=False,timeout=httpx.Timeout(30.0, connect=10.0),limits=httpx.Limits(max_keepalive_connections=20, max_connections=100))
        
    async def close(self):
        #Call this on app shutdown
        await self.client.aclose()
    
    async def check_credits(self):

        try:
            params_values={'API_Key':self.dmasa_api_key,'MemberID':self.dmasa_member_id}
            resp = await self.client.get(self.check_credits_dmasa_url, params=params_values)
            resp.raise_for_status()
            data = resp.json()
            return data['Credits'] 
        except httpx.HTTPStatusError as exc:
           
           dma_logger.error(f"DMASA credit check failed [{exc.response.status_code}]: {exc.response.text}")
           raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY,detail="Failed to connect to DMASA credit check service")
        
        except (KeyError, ValueError, httpx.RequestError) as exc:
            dma_logger.error(f"Invalid response from DMASA credits: {exc}")

            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY,detail="Invalid response from DMASA service")


    async def upload_data_for_dedupe(self,data:List[str],session:AsyncSession,camp_code:str):

        campaign_code=camp_code

        payload={
            "API_Key":self.dmasa_api_key,
            "Data":data,
            "DataType":"C",
            "MemberID":self.dmasa_member_id,
            "NotificationEmail":self.notification_email
        }


        try:
            resp = await self.client.post(self.submit_dedupes_dmasa_url,data=json.dumps(payload),timeout=httpx.Timeout(540.0)) 
            resp.raise_for_status()
            result = resp.json()

            errors = result.get("Errors")
            if errors:
                dma_logger.error(f"DMASA rejected upload: {errors}")
                raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,detail=f"DMASA rejected data: {errors}")
            
            audit_id = result['DedupeAuditId']
            records_processed = result['RecordsProcessed']
            # Create and save audit record
            audit_record = dma_audit_id_tbl(
                audit_id=audit_id,
                number_of_records=int(records_processed),
                notification_email=self.notification_email,
                camp_code=campaign_code
            )

            session.add(audit_record)
            await session.commit()
            await session.refresh(audit_record)
            dma_logger.info(f"DMASA upload successful | AuditID: {audit_id} | Records: {records_processed}")
            return audit_record.audit_id
        
        except httpx.HTTPStatusError as exc:
            dma_logger.error(f"DMASA upload failed [{exc.response.status_code}]: {exc.response.text}")
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Failed to upload data to DMASA")
        
        except (KeyError, ValueError, httpx.RequestError) as exc:
            dma_logger.error(f"Invalid DMASA upload response: {exc}")
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Invalid response from DMASA")

    async def check_dedupe_status(self,audit_id,session:AsyncSession):
        print("enter check dedupe status method")
        try:
            record_query=await session.execute(select(dma_audit_id_tbl).where(dma_audit_id_tbl.audit_id==audit_id))
            record=record_query.scalars().one_or_none()

            if not record:
                raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,detail=f"An invalid or unknwon audit id submitted")
                
            url = f"{self.read_dmasa_dedupe_status}?API_Key={self.dmasa_api_key}&MemberID={self.dmasa_member_id}&DedupeAuditId={audit_id}"

            response = await self.client.get(url, timeout=60.0)
            print("print the main response")
            print(response.json())
            response.raise_for_status()
            data = response.json()
            print("print the dedupe status check results")
            print(data)
            status_value = data.get('Status', '')
            print()
            print()
            print("print the dedupe status value")
            print(status_value)
            if status_value in ('Download Ready', 'Dedupe Complete'):
                record.is_processed = True
                # process the data fetched from dmasa
                record.number_of_records=int(data['TotalRecords'])
                record.dedupe_status=status_value
                session.add(record)
                await session.commit()
                dma_logger.info(f"Dedupe complete for AuditID: {audit_id}")
                return True
            return False
        
        except httpx.RequestError as exc:
            dma_logger.error(f"Network error checking status for {audit_id}: {exc}")
            return False
        
        except Exception as exc:
            dma_logger.exception(f"Unexpected error checking dedupe status {audit_id}: {exc}")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,detail="Internal error while checking dedupe status")
    
    async def read_dedupe_output(self,dma_audit_id):
        try:
            resp = await self.client.get(self.read_dedupe_output_url,params={"MemberID": self.dmasa_member_id,"API_Key": self.dmasa_api_key,"AuditId": dma_audit_id}, timeout=300.0)
            resp.raise_for_status()
            result = resp.json()
            print("download the dedupe result")
            print(result)
            
            errors = result.get("Errors", [])
            if errors:
                dma_logger.error(f"DMASA read output errors for {dma_audit_id}: {errors}")
                raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE,detail=f"DMASA returned errors: {errors}")
            
           # Handle all possible key variations
            return (result.get("ReadOutput") or result.get("Output") or result.get("ReadOuput"))
            
        except httpx.RequestError as exc:
            #need better return or exception propagation
            dma_logger.error(f"Failed to read dedupe output for {dma_audit_id}: {exc}")
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY,detail="Failed to retrieve dedupe results from DMASA")
        
        except ValueError as valueError:
            dma_logger.exception(f"A value error exception occurred while reading the dedupe records:{valueError}")
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY,detail=f"An error occurred on the dmasa api")
            
        except Exception as exc:
            dma_logger.exception(f"Error reading dedupe output for {dma_audit_id}: {exc}")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,detail="Internal error while reading dedupe results")
    
    #This method wait for a maximum of 25 seconds wait for the dedupe to be ready

    async def wait_for_download_to_be_ready(self,session:AsyncSession,audit_id,max_retries=5,delay=5):

        print("enter wait for download to be ready method")
        print(f"print the dedupe audit id inside the download method:{audit_id}")

        for _ in range(max_retries):
            dedupe_status=await self.check_dedupe_status(audit_id,session)
            print(dedupe_status)
            if dedupe_status in ('Download Ready', 'Dedupe Complete'):
                print("print the dedupe status inside the true statements")
                print(dedupe_status)
                return True
            print("print check again without returning completely from the method")
            await asyncio.sleep(delay)

        return True

#Factory function for dependency injection

async def get_dmasa_service_helper():
    service = DMAClassHelper()
    try:
        yield service

    finally:
        await service.close()



DMAService = Annotated[DMAClassHelper, Depends(get_dmasa_service_helper)]